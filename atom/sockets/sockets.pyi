import asyncio
import socket as _socket
import concurrent.futures
import ssl as _ssl
import sys

from typing import (
    Callable,
    List,
    Tuple,
    Optional,
    Union,
    overload,
    IO,
    Type,
    TypeVar,
    Iterable,
    Any
)

from .protocols import Protocol
from .utils import (
    ServerContextManager,
    ConnectionContextManager
)

_R = List[Tuple[_socket.AddressFamily, _socket.SocketKind, int, str, Tuple[str, int] | Tuple[str, int, int, int]]]
_T = TypeVar('_T')
_A = Tuple[int, int, bytes]

class HostAddress:
    def __init__(self, host: Tuple[str, List[str], List[str]]) -> None: ...
    @property
    def hostname(self) -> str: ...
    @property
    def aliases(self) -> List[str]: ...
    @property
    def ipaddrlist(self) -> List[str]: ...

class Address:
    def __init__(self, __addr: Tuple[str, int], __socket: 'socket'): ...
    @property
    def host(self) -> str: ...
    @property
    def port(self) -> int: ...
    async def getinfo(self) -> _R: ...
    async def gethost(self) -> Union[str, HostAddress]: ...
    def as_tuple(self) -> Tuple[str, int]: ...

class socket:
    loop: asyncio.AbstractEventLoop

    def __init__(self,
                family: int = ...,
                type: int = ...,
                proto: int = ..., 
                *,
                sock: _socket.socket = ...,
                ssl: _ssl.SSLContext = ..., 
                loop: asyncio.AbstractEventLoop = ...,
                executor: concurrent.futures.Executor = ...):
        ...
    def __repr__(self) -> str: ...
    async def __aenter__(self) -> 'socket': ...
    async def __aexit__(self) -> None: ...
    @property
    def ssl_context(self) -> _ssl.SSLContext: ...
    @property
    def family(self) -> int: ...
    @property
    def type(self) -> int: ...
    @property
    def proto(self) -> int: ...
    @property
    def fileno(self) -> int: ...
    @property
    def is_ssl(self) -> bool: ...
    @property
    def is_closed(self) -> bool: ...
    @property
    def is_connected(self) -> bool: ...
    @property
    def is_bound(self) -> bool: ...
    @property
    def laddr(self) -> Optional[Address]: ...
    @property
    def raddr(self) -> Optional[Address]: ...
    def _run_in_executor(self, func: Callable[..., _T], *args, **kwargs) -> asyncio.Future[_T]: ...
    def _run_socket_operation(self, func: Callable[..., _T], *args, **kwargs) -> asyncio.Future[_T]: ...
    if sys.platform in ('win32', 'linux'):
        async def if_nameindex(self) -> List[Tuple[int, str]]: ...
        async def if_nametoindex(self, name: str) -> int: ...
        async def if_indextoname(self, index: int) -> str: ...
    if sys.platform == 'win32':
        async def ioctl(self, control: int, option: Union[int, Tuple[int, int, int], bool]) -> None: ...
        def share(self, process: int) -> None: ...
    async def gethostbyaddr(self, address: str) -> HostAddress: ...
    async def gethostbyname(self, name: str) -> str: ...
    async def gethostbyname_ex(self, name: str) -> Tuple[str, List[str], List[str]]: ...
    async def getaddrinfo(self, host: str, port: int, flags: int=...) -> _R: ...
    async def getnameinfo(self, 
                        sockaddr: Union[Tuple[str, int], Tuple[str, int, int, int]], 
                        flags: int=...) -> Tuple[str, str]: ...
    async def gethostname(self) -> str: ...
    async def getprotobyname(self, name: str) -> int: ...
    async def getservbyname(self, service: str, protocol: str) -> int: ...
    async def getservbyport(self, port: int, protocol: str) -> str: ...
    def inet_aton(self, ipaddress: str) -> bytes: ...
    def inet_pton(self, family: int, ipaddress: str): ...
    def inet_ntao(self, packed: bytes): ...
    def inet_ntop(self, family: int, packed: bytes): ...
    def ntohl(self, x: int) -> int: ...
    def ntohs(self, x: int) -> int: ...
    def htonl(self, x: int) -> int: ...
    def htons(self, x: int) -> int: ...
    def get_inheritable(self) -> bool: ...
    def set_inheritable(self, inheritable: bool) -> None: ...
    async def getpeername(self) -> Address: ...
    async def getsockname(self) -> Address: ...
    async def recv(self, nbytes: int=...) -> bytes: ...
    async def recv_into(self, buffer: bytearray, nbytes: int=...) -> int: ...
    async def recvfrom(self, bufsize: int=...) -> Tuple[bytes, Tuple[int, bytes]]: ...
    async def recvfrom_into(self, buffer: bytearray, nbytes: int=...) -> Tuple[int, Tuple[int, bytes]]: ...
    @overload
    async def recvall(self, nbytes: int=...) -> bytearray: ...
    @overload
    async def recvall(self, nbytes: int=..., buffer: bytearray=...) -> None: ...
    if sys.platform != "win32":
        async def recvmsg(
            self, bufsize: int=..., ancbufsize: int=..., flags: int=...
        ) -> Tuple[bytes, List[_A], int, Any]: ...
        async def recvmsg_into(
            self, buffers: Iterable[bytearray], ancbufsize: int=..., flags: int=...
        ) -> Tuple[int, List[_A], int, Any]: ...
    async def send(self, data: bytes) -> int: ...
    async def sendto(self, data: bytes, address: Address) -> int: ...
    async def sendfile(self, file: IO[bytes], *, offset: int=..., count: int=...): ...
    if sys.platform != "win32":
        async def sendmsg(
            self, buffers: Iterable[bytes], ancdata: Iterable[_A] = ..., flags: int = ..., address: Address = ...
        ) -> int: ...
    if sys.platform == "linux":
        async def sendmsg_afalg(
            self, msg: Iterable[bytes] = ..., *, op: int, iv: Any = ..., assoclen: int = ..., flags: int = ...
        ) -> int: ...
    async def connect(self, host: str, port: int, *, ssl: bool=...) -> Address: ...
    async def connect_ex(self, host: str, port: int, *, ssl: bool=...) -> Address: ...
    async def bind(self, host: str, port: int) -> Address: ...
    async def accept(self, timeout: int=...) -> Tuple['socket', Address]: ...
    async def listen(self, backlog: int=...) -> int: ...
    def create_connection(self, host: str, port: int) -> ConnectionContextManager: ...
    def create_server(self, host: str, port: int, backlog: int=...) -> ServerContextManager: ...
    async def open_connection(self, 
                            protocol: Type[Protocol], 
                            host: str,
                            port: int, *, 
                            ssl: bool=...): ...
    def duplicate(self) -> 'socket': ...
    def close(self) -> None: ...
    def shutdown(self, how: int) -> None: ...
    def setsockopt(self, level: int, optname: int, value: Union[int, bytes]) -> None: ...
    def settimeout(self, timeout: int=...) -> int: ...