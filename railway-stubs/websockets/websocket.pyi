from .frame import WebSocketCloseCode, WebSocketFrame, WebSocketOpcode, Data
from railway.stream import StreamReader, StreamWriter
from railway._types import peer
from typing import Any, Dict, Optional

class ServerWebsocket:
    peername: peer = ...
    def __init__(self, reader: StreamReader, writer: StreamWriter) -> None: ...
    def is_closed(self): ...
    def feed_data(self, data: bytes) -> Any: ...
    async def send_frame(self, frame: WebSocketFrame) -> int: ...
    async def send_bytes(self, data: bytes, *, opcode: Optional[WebSocketOpcode]=...) -> int: ...
    async def send(self, data: bytes, *, opcode: Optional[WebSocketOpcode]=...) -> int: ...
    async def send_str(self, data: str, *, opcode: Optional[WebSocketOpcode]=...) -> int: ...
    async def send_json(self, data: Dict[str, Any], *, opcode: Optional[WebSocketOpcode]=...) -> int: ...
    async def ping(self, data: bytes) -> Any: ...
    async def pong(self, data: bytes) -> Any: ...
    async def continuation(self, data: bytes) -> Any: ...
    async def binary(self, data: bytes) -> Any: ...
    async def close(self, data: bytes, code: Optional[WebSocketCloseCode]=...) -> None: ...
    async def receive(self) -> Data: ...
    async def receive_bytes(self) -> bytes: ...
    async def receive_str(self) -> str: ...
    async def receive_json(self) -> Dict[str, Any]: ...

class ClientWebsocket(ServerWebsocket):
    async def send_frame(self, frame: WebSocketFrame) -> int: ...
    async def receive(self) -> Data: ...
