import asyncio
from railway.streams import StreamReader, StreamWriter
import socket
import ssl
from typing import Any, List, Optional, Union

class ClientProtocol(asyncio.Protocol):
    loop: asyncio.AbstractEventLoop = ...
    reader: StreamReader = ...
    writer: StreamWriter = ...
    waiter: 'asyncio.Future[None]' = ...
    def __init__(self, loop: asyncio.AbstractEventLoop) -> None: ...
    def __call__(self): ...
    def connection_made(self, transport: asyncio.Transport) -> None: ...
    def data_received(self, data: bytes) -> None: ...
    def pause_writing(self) -> None: ...
    def resume_writing(self) -> None: ...
    def connection_lost(self, exc: Optional[Exception]) -> None: ...
    async def wait_for_close(self) -> None: ...

class Client:
    host: str = ...
    port: int = ...
    sock: socket.socket = ...
    ssl_context: ssl.SSLContext = ...
    loop: asyncio.AbstractEventLoop = ...
    def __init__(self, host: Optional[str]=..., port: Optional[int]=..., *, sock: Optional[socket.socket]=..., ssl_context: Optional[Union[ssl.SSLContext, Any]]=..., loop: Optional[asyncio.AbstractEventLoop]=...) -> None: ...
    async def __aenter__(self): ...
    async def __aexit__(self, *args: Any) -> Any: ...
    def __await__(self): ...
    def is_connected(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def is_ssl(self) -> bool: ...
    async def connect(self) -> Client: ...
    async def write(self, data: Union[bytearray, bytes], *, timeout: Optional[float]=...) -> None: ...
    async def writelines(self, data: List[Union[bytearray, bytes]], *, timeout: Optional[float]=...) -> Any: ...
    async def receive(self, nbytes: Optional[int]=..., *, timeout: Optional[float]=...) -> bytes: ...
    async def close(self) -> None: ...

def create_connection(host: str, port: int, *, ssl_context: Optional[Union[ssl.SSLContext, Any]]=..., loop: Optional[asyncio.AbstractEventLoop]=...) -> Client: ...
